/*******************************************************************************
 *  Copyright (c) 2012 Google, Inc.
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  which accompanies this distribution, and is available at
 *  http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *  Google, Inc. - initial API and implementation
 *******************************************************************************/
package com.windowtester.recorder.event.meta;

import com.windowtester.recorder.event.IRecorderSemanticEvent;
import com.windowtester.recorder.event.ISemanticEventHandler;
import java.util.HashMap;
import java.util.Map;

/**
 * An enum class for recorder Meta events.
 */
public class RecorderMetaEvent implements IRecorderSemanticEvent {

  // generated by serialver
  static final long serialVersionUID = 64616131365L;

  /**
   * This event's name
   *
   * @serial
   */
  private final String name;

  /**
   * Create an instance.
   *
   * @param name - the event's name
   */
  public RecorderMetaEvent(String name) {
    this.name = name;
  }

  /* (non-Javadoc)
   * @see java.lang.Object#toString()
   */
  public String toString() {
    return name;
  }

  /**
   * Replace the deserialized instance with its associated static object (required for proper serialization).
   *
   * @return the associated static object
   */
  private Object readResolve() {
    return get(name);
  }

  /**
   * A name-based factory.
   *
   * @param name - the name
   * @return the associated event type, or null if there is none
   */
  public static RecorderMetaEvent get(String name) {
    return (RecorderMetaEvent) types.get(name);
  }

  /* (non-Javadoc)
   * @see com.windowtester.recorder.event.ISemanticEvent#accept(com.windowtester.recorder.event.ISemanticEventHandler)
   */
  public void accept(ISemanticEventHandler handler) {
    if (this == DISPOSE) {
      handler.handleDispose(this);
    }
    if (this == START) {
      handler.handleStart(this);
    }
    if (this == STOP) {
      handler.handleStop(this);
    }
    if (this == RESTART) {
      handler.handleRestart(this);
    }
    if (this == PAUSE) {
      handler.handlePause(this);
    }
    if (this == TOGGLE_SPY) {
      handler.handleSpyModeToggled(this);
    }
  }

  ////////////////////////////////////////////////////////////////////////////
  //
  // Labels
  //
  ////////////////////////////////////////////////////////////////////////////

  public static final String START_LABEL = "START";
  public static final String STOP_LABEL = "STOP";
  public static final String DISPOSE_LABEL = "DISPOSE";
  public static final String RESTART_LABEL = "RESTART";
  public static final String PAUSE_LABEL = "PAUSE";
  public static final String TOGGLE_SPY_LABEL = "SPY";
  ////////////////////////////////////////////////////////////////////////////
  //
  // Event types
  //
  ////////////////////////////////////////////////////////////////////////////

  public static final IRecorderSemanticEvent START = new RecorderMetaEvent(START_LABEL);
  public static final IRecorderSemanticEvent STOP = new RecorderMetaEvent(STOP_LABEL);
  public static final IRecorderSemanticEvent DISPOSE = new RecorderMetaEvent(DISPOSE_LABEL);
  public static final IRecorderSemanticEvent RESTART = new RecorderMetaEvent(RESTART_LABEL);
  public static final IRecorderSemanticEvent PAUSE = new RecorderMetaEvent(PAUSE_LABEL);

  public static final IRecorderSemanticEvent TOGGLE_SPY = new RecorderMetaEvent(TOGGLE_SPY_LABEL);

  /**
   * A map that contains mappings from labels to registered event types
   */
  private static final Map types = new HashMap();

  static {
    types.put(START_LABEL, START);
    types.put(STOP_LABEL, STOP);
    types.put(DISPOSE_LABEL, DISPOSE);
    types.put(RESTART_LABEL, RESTART);
    types.put(PAUSE_LABEL, PAUSE);
    types.put(TOGGLE_SPY_LABEL, TOGGLE_SPY);
  }
}
